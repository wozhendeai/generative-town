/**
 * Programmatic prompt generation from SpritesheetMetadata.
 * Pure function - no AI needed.
 */

import type { SpritesheetMetadata, Sprite, SpriteCategory } from '../types';
import { GRID_CONFIG, DERIVED_CONFIG } from '../config';

/**
 * Generate scene direction header with camera, lighting, and style info.
 * This is stated once at the top instead of repeating per tile.
 */
function generateSceneHeader(theme: string): string {
  return `## Scene Direction

**Camera**: Elevated 3/4 overhead view (classic JRPG perspective)
**Lighting**: Key light from top-left, shadows fall toward bottom-right
**Style**: Crisp pixel art with defined edges, no smoothing
**Palette**: Consistent ${theme} aesthetic across all tiles

When tiles are placed adjacent, they should feel like one continuous scene.`;
}

/**
 * Get perspective-specific prefix for each sprite based on category.
 * Concise since camera/lighting/style are in the scene header.
 */
function getPerspectivePrefix(category: SpriteCategory): string {
  switch (category) {
    case 'ground':
      return 'Pure overhead view, flat surface only.';
    case 'building':
      return '3/4 view showing roof and front wall.';
    case 'prop':
      return '3/4 view object with clear silhouette.';
    case 'wall':
      return '3/4 view showing top edge and front face.';
    case 'marker':
      return 'Game UI marker, floating/glowing effect.';
  }
}

/**
 * Generate an image prompt from spritesheet metadata.
 * This replaces the Architect agent with a deterministic transformation.
 */
export function generatePromptFromMetadata(metadata: SpritesheetMetadata): string {
  // Group sprites by row
  const spritesByRow = new Map<number, Sprite[]>();
  for (const sprite of metadata.sprites) {
    const existing = spritesByRow.get(sprite.row) || [];
    existing.push(sprite);
    spritesByRow.set(sprite.row, existing);
  }

  // Build layout lines matching existing format
  const layoutLines: string[] = [];
  for (let row = 0; row < DERIVED_CONFIG.rows; row++) {
    const sprites = spritesByRow.get(row) || [];
    if (sprites.length === 0) continue;

    sprites.sort((a, b) => a.col - b.col);
    layoutLines.push(`Row ${row}:`);

    for (const s of sprites) {
      const sizeNote = (s.w > 1 || s.h > 1) ? ` [${s.w}x${s.h} tiles]` : '';
      const prefix = getPerspectivePrefix(s.category);
      layoutLines.push(`- (${s.col},${row}): ${prefix} ${s.description}${sizeNote}`);
    }
  }

  return `# Spritesheet Prompt

## Technical Spec
- Canvas: ${DERIVED_CONFIG.columns} columns x ${DERIVED_CONFIG.rows} rows (${DERIVED_CONFIG.totalTiles} tiles total)
- Tile size: ${GRID_CONFIG.tileSize}x${GRID_CONFIG.tileSize} pixels each
- Background: Pure white (#FFFFFF) for transparency masking
- Each sprite fully contained within its tile boundaries

${generateSceneHeader(metadata.theme)}

## Layout
Coordinate system: (col, row) where columns 0-${DERIVED_CONFIG.columns - 1} left to right, rows 0-${DERIVED_CONFIG.rows - 1} top to bottom.

${layoutLines.join('\n')}

---
Generated by Designer Agent
`;
}
